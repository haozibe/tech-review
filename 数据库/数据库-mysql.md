## Mysql

- 索引B树,B+树区别
- 引擎常用的有MyIsam跟Innodb。MyIsam查询效率高，支持全文索引，不支持事务，表级锁，不支持外键，插入慢，MyIsam用一个变量保存了表的行数，做count统计时只需要读该变量的值。用于插入少，查询多的表。Innodb查询效率低，不支持全文索引，支持事务，行级锁，支持外键，插入快，count操作需要遍历全表，支持MVCC。MyIsam的自增主键的最大值是记录在文件里的，重启不会丢失。Innodb的自增最大主键是记录在内存中的，重启会丢失。
- Mysql事务隔离级别，1.read uncommit:禁止多个事务同时修改同一条记录，其他事务可以同时读取未提交的修改。隔离级别最低，会出现脏读，不重复读和幻读。2.read commit：禁止多个事务同时修改同一条记录记录，修改在提交前，其他事务只能读取在修改前的版本。不会出现脏读，但是会出现不可重复读和幻读。3.repeaded Read禁止多个按实物同时修改同一条记录，事务提交前会锁住所有读取到的行，禁止其他事务修改它正在读取的行。默认隔离级别，不会出现脏读，不可重复读，但会出现幻读。4.Serializable：串行化执行，会锁住所有涉及到的数据表。可以解决脏读、不可重复读和幻读，隔离级别最高，并发性能最低。
- mysql如何做分库分表，读写分离，主从复制。
- sql优化,expalin命令看索引,避免用in跟with还有like通配符，使用count(*)替代count(1),
- sql怎么避免全表扫描
  1. 避免用select *,查询时指明字段。
  2. 用like时，百分号在左边可以命中索引，百分号在右边会全表查询。
  3. oracle9i用is null会单索引失败，避免用is null 用 not null关键字。
  4. 不等号操作会导致全表查询。
- mysql索引类型：
  1. Btree，Innnodb采用的是变种的B+tree,MyISAM采用的是Btree，其中心思想是所有值都是经过排序的，所有叶子节点到节点的距离相等。
  2. Rtree 只有MyISAM支持
  3. Full-text，fulltext索引会根据某个关键字进行全文搜索，更类似于搜索引擎，可以配合Btree一起使用，只有在使用match against时生效。而不是where like。
  4. hash，hash索引检索快，但是只支持精确查找，不支持范围查找跟排序。
- Mysql配合keeplive做HA。
- 事务的特性：
  1. 原子性 事务中的所有操作，要不就全部成功，要不就全部失败
  2. 隔离性 当前事务不被其他事务干扰，事务执行的中间结果对其他事务是透明的。
  3. 一致性 事务的执行结果跟事务多个操作串行执行的结果是一致的
  4. 持久性 对任意已提交的事务，系统必须保证该事务对数据库的改变不会丢失，即使数据库出错。
- 并发事务可能导致的问题：
  1. 脏读，读取到其他线程已修改还未提交的数据。
  2. 不可重复读，同一事务多次读取4'yi数据，因为其他事务也去修改，导致同一事务多次读取到的数据不一致。
  3. 幻读，当前事务在读取多行数据时，由于其他事务插入操作，导致读出不存在的多条记录。
  4. 丢失修改，同时有两事务对同一数据进行修改，在第一个事务修改之后第二个事务也对该数据进行修改，第一个事务的修改结果丢失了。
- B+树叶子节点储存了什么数据：有可能储存正行数据，也有可能储存主键的值。
- 识别度最高的索引放在最左边，因为联合索引最左前缀匹配。当最左边的key能命中时，该联合索引生效。
- 非聚簇索引如果符合覆盖索引可以只查询一次。就是查询结果只从索引中就能取得，就不必从数据表读取。
- explain有参数 key 
- myisamchk用于压缩MyISAM表，减少内存和磁盘使用。
- Mysql中允许有多少个触发器，6个，对应before,after,insert,update,delete。

### 分库分表

- 垂直切分 根据不同的业务划分 将同类的表归到不同的数据库
- 水平切分 根据表中的某些字段，按一定的规则分散到多个库中，每个库中包含一部分数据。
- 读写分离

##### 水平分库如何分页

1. 全局视野法。
   - 优点：通过修改sql语句扩大返回数据集，再在内存进行排序，业务上无数据精度损失。
   - 缺点：增大了网络损耗、二次排序增加服务器计算量、随着页码增加性能急剧下降。
2. 禁止跳页查询法
   - 优点：每次只查一页的数据，通过依赖上一页的排序字段进行筛选。
   - 缺点：需要业务进行妥协。
3. 允许数据精度损失法
   - 优点：每个库各偏移一半，获取半页数据，进行合并，性能高。
   - 缺点：需要业务妥协允许数据精度损失，数据精度依赖于分布均匀度。
4. 二次查询法
   - 优点： 性能高，通过获取各个分库的筛选字段最小值，确定各个分库的offset，累加即可以拿到全局视野的offset。

### 数据库三大范式

- 所有列都不可再分割
- 所有非主键依赖于主键全部，而不依赖于主键的某一部分。
- 所有非主键只依赖于主

### mycat做读写分离

### 如何优化一个慢查询

1. mysql提供了满查询日志，show variables like 'slow_query'可以找到慢查询日志。
2. 通过mysqldumpslow导出慢查询日志的总结报告。
3. 先看能不能通过改sql的方法优化性能。
4. 先看能不能通过优化索引的方法，优化性能。



### Mysql事务实现原理

MVCC Multi Version Concurrent Control多版本并发控制，undo log中的行就是MVCC中的多版本，Mysql中修改时加入了排它锁，实现的不是理想的MVCC，是串行的，innodb只是借了MVCC的名字，提供了读的非堵塞而已。

真正的MVCC是类似乐观锁，可以实现多版本共存的。实现不了的原因是不能保证一致性。

- redo log 保存执行的sql后的数据到指定的log文件，不管事务是否提交都会记录下来，当执行recovery时重新执行redo log记录的sql操作，当客户执行更新操作时，redo log会首先写入到log buffer，待用户执行commit命令时，log buffer会把内容刷新到磁盘中，保留在innodb的log文件。
- undo log undo log是为了回滚用的，没有单独的undo log文件，所有undo log均放在主ibd数据文件中（表空间），会复制事务前的内容到undo buffer中，在合适的时间吧undo buffer的内容刷新到磁盘。
- rollback segment undo log中的回滚段
- 锁
- 隔离级别



# Mysql的日志

## binlog 专题

### binlog参数

- 保存了执行的sql及反向的操作，用于主从复制和主从同步，用于数据库的是时间点还原
- binlog默认的保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数后，自动删除

#### binlog三种存入方式

1. statement

   记录对数据有改动的每一条sql，因为主从同步，master跟slave需要保持一致，所以还需要记录一些执行时相关的信息。增加了主从同步的复杂度。在一些特定的函数上，会存在主从同步不一致的问题。

2. row

   可以不记录上下文执行的信息，需要记录每一行的改动，如果是设计到修改表结构的话，会产生大量的行改动日志。

3. mixed

   混合模式，根据执行的场景选定存入的方式。默认是通过statement存入，如果statement执行的函数无法进行主从同步一致，会采用row的方式去存。

   

| format    | 定义                       | 优点                           | 缺点                                                         |
| :-------- | :------------------------- | :----------------------------- | :----------------------------------------------------------- |
| statement | 记录的是修改SQL语句        | 日志文件小，节约IO，提高性能   | 准确性差，对一些系统函数不能准确复制或不能复制，如now()、uuid()、limit(由于mysql是自选索引，有可能master同salve选择的索引不同，导致更新的内容也不同)等在某些情况下会导致master-slave中的数据不一致(如sleep()函数， last_insert_id()，以及user-defined functions(udf)等会出现问题) |
| row       | 记录的是每行实际数据的变更 | 准确性强，能准确复制数据的变更 | 日志文件大，较大的网络IO和磁盘IO                             |
| mixed     | statement和row模式的混合   | 准确性强，文件大小适中         | 当binlog format 设置为mixed时，普通复制不会有问题，但是级联复制在特殊情况下会binlog丢失。 |

### binlog结构和内容



### binlog事件机制

重要的事件机制：

1. QUERY_EVENT 查询时间
2. FORMAT_DESCRIPTION_EVENT binlog第一个日志，只会出现一次，其他事件根据他解析定义。
3. ROWS_EVENT row格式的binlog，会记录所有的DML语句。
4. XID_EVENT 事务提交，会添加XID_EVENT作为事务的结束。
5. ROTATE_EVENT 

## 事务日志redo log和undo log专题

### redo log 和bin log区别

- redo log属于innodb层面，binlog属于Mysql Server层面，这样在数据库用别的储存引擎时可以保持一致性
- redo log是物理日志，记录该数据页更新的内容；bin log属于逻辑日志，记录的是这个更新语句的原始逻辑
- redo log是循环写，日志空间大小固定；bin log是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖
- binlog可以作为数据恢复使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用
- Redo log在事务开始时，逐步写入到磁盘，bin log是在事务提交时一次过写入到磁盘

### undo + redo

- 为了保证持久性，必须在事务提交前将RedoLog持久化
- 数据不需要再事务提交前写入磁盘，而是缓存到内存中
- RedoLog保证事务的持久性
- UndoLog保证事务的院子性
- 数据必须晚于redo log写入持久

## Mysql的锁

### 隐式和显式锁定

服务层SELECT LOCK IN SHARE MODE SELECT FOR UPDATE



## 表结构优化

#### 字段

1. 字符集尽量选择使用UTF-8。
2. 查询频繁的表，设置主键，主键最好是自增的。
3. 建了索引的字段必须加上not null并设置default值，不建议使用float和double存小数，防止精度丢失，建议使用decimal。
4. 不建议使用text/blob保存大量数据，因为对文本的读写会造成比较大的IO开支，同时占用mysql缓存，高并发下会极大降低数据库的吞吐量，建议将大文本数据保存在专门的文件存储系统，mysql只保存这个文件的访问地址，比如博客文章可以保存在文件中，mysql只保存文件的相对位置。
5. varchar类型长度建议不超过8k。
6. 时间类型建议使用DateTime，不要使用timestamp，虽然DateTime占用8字节，而timestamp只占用4字节，但是后者要保证非空，而且后者对时区敏感。
7. 建议表中增加gmt_create和gmt_modify字段，用于记录数据创建的修改时间。

#### 索引

1. 如非必要，尽量不要盲目加索引，会影响插入效率。
2. 创建innodb索引的长度不要超过767bytes，如果超过会使用前255bytes作为前缀索引。
3. 创建联合索引的单个索引长度不要超过767bytes，一共加起来不要超过3072bytes。

#### sql优化

1. 尽量避免用select *,需要查什么字段就查什么字段，查询时尽量命中索引。
2. 不做列运算，所有对列的操作都会导致全表扫描。
3. 分页先找出id再设置where id>多少来分，不要一次过分页，这样越往后翻页性能越低。
4. between 大于 小于这种不会走索引，in数量较小的话可以走索引。
5. 全模糊查询不会走索引，只有右模糊会走索引
6. 用join替代子连接，union代替union all。多表连接尽量不要超过三张表。
7. 避免使用like左模糊和全模糊，只有like右模糊能命中索引。
8. 用or时，如果判断条件一边有索引，一边没索引会无法命中索引。
9. 避免使用is null，Oracle9单索引失败，is not null永远不会使用索引。
10. update语句，只update修改的字段。
11. 用unionAll代替union，然后在应用程序中做去重。
12. 避免使用select count(*)或者select count(1)
13. 用join代替子查询。
14. 避免使用不等号操作符。
15. 使用组合索引时，要符合最左前缀匹配原则，否则排序时按组合索引的顺序排序。
16. =和in支持联合索引乱序，例如where a=1 and b= 2 and c =3;
17. 尽量选择区分度高的列作为索引，通过count(distinct col)/count(*)算出区分度，主键的区分度为1，需要join的字段区分度至少要是0.1以上。
18. 索引列不能参与计算，因为b+树村的都是数据表中的字段值，但进行检索时，必须把所有元素都应用函数才能比较，显然成本太大。
19. 尽量拓展索引。

#### 数据库连接池优化

1. initialSize 初始连接数，可以设置为并发量的历史平均值。
2. minIdle 最小保留的控空闲连接，一般设为5，如果并发很小可以设为1。
3. maxIdle 最大保留的空闲连接，根据并发峰值设置，并发峰值为20，高峰过后，这些连接不会马上被回收
4. maxActive 最大活跃连接数 单机并发量可承受极值时100
5. maxWait 获取连接的最大等待时间
6. minEvicatableIdleTimeMillis 连接保持空闲而不被回收的时间，默认30分钟
7. validateQuery 测试连接是否有效的sql，心跳
8. testOnReturn 申请连接时对连接进行检测，不建议开启，严重影响性能
9. 预热连接池 建议在启动应用时对数据库进行预热，让连接池充满必要的连接数



### 主备库不一致场景及解决方案

1. 备库写数据。
2. 执行不确定的查询。
3. binlog或relaylog有损坏。
4. 回滚掺杂事务表和非事务表。

#### 如何避免

1. Checksum
2. 禁止写从库
3. 使用row-based relication
4. 避免同一个事务中用到innodb表和myisam表

### 主从同步延时长，怎么进行优化

1. 多线程重放relaylog日志。通过hash取模确定需要重放的库。通过GTID确定对同一个事务的操作是由同一个线程执行，避免发生错乱。







## 内存结构

### SGA 系统全局区

1. Query_Cache: 查询缓存，生产不建议打开
2. innodb_buffer_pool: 缓存innodb的数据、索引、字典、插入缓冲等。 
3. innodb_log_buffer：redo_log_buffer大小，事务在内存中的缓存。
4. key_buffer_size: 缓存myisam储存。
5. innodb_additional_mem_pool_size: 缓存数据字典及其他内部数据结构缓存池大小。

### PGA 程序缓存区

1. sort_buffer_size
2. read_buffer_size
3. join_buffer_size
4. read_rnd_buffer_size
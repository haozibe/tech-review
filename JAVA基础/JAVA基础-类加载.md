## 类的加载机制

- BootStrap  ClassLoader(C++对象) -> ext ClassLoader -> application ClassLoader -> 自定义的ClassLoader
- 双亲委派机制，当一个类加载器收到加载请求时，总会先往当前类的加载器往上找他的父类加载器，如果父类加载器无法加载该类才由它去加载，永远不会往下找加载器，如果直到当前的加载器也找不到加载的类，则报ClassNotFoundException错误。

### 类的生命周期

- 加载 loading -> 验证 verification -> 准备prepare  -> 解析 resolution -> 初始化 initialization-> 使用 using-> 卸载 unloading
- 实例化一个对象的三个步骤：实际执行时可能按123或132执行，因为发生了指令重排序
  1. 分配内存空间。
  2. 初始化对象。
  3. 将内存空间的值分配给对象的引用。

### 触发类加载场景

1. 遇到new、getstatic、putstatic、invokestatic这四个字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。使用new关键字实例化时，读取或设置一个类的静态字段时，以及调用一个类的静态方法时。
2. 通过java.lang.reflect包的方法对类进行反射调用时，如果类没有发生初始化，会先进行加载。
3. 初始化一个类的时候，如果父类没有进行过初始化，会先触发父类的初始化。
4. 虚拟机启动时，用户需要制定一个执行的主类，虚拟机会先初始化这个类。

### 对象创建和内存分配

1. 指针碰撞 堆内存是完全工整的，使用的时候只需要指针往空闲内存移动一段和内存大小相等的区域，如果带有压缩功能的垃圾收集器，就是采用指针碰撞的方式进行内存的分配，内存分配时的并发问题通过乐观锁解决。
2. 空闲列表 需要JVM维护一个空闲的列表，分配时直接从可用内存分配



### Tomcat破坏双亲委派机制

tomcat需要让每个web应用稳定运行，需要破坏双亲委派机制，让每个web的类都用不同的类加载器去加载。

Common,catalina,shared类加载器来加载tomcat的核心类库。

Webapp,jsp类加载器来加载web应用和jsp文件。

- tomcat支持各个web引用中不同版本的三方类库相互隔离。
- 同一个第三方类库的相同版本在不同web应用可以共享。
- tomcat自身依赖的类库需要与应用依赖的类库隔离 。
- jsp需要支持修改后不用重启tomcat即可生效 为了上面类加载隔离和类更新不用重启，定制开发各种的类加载器。


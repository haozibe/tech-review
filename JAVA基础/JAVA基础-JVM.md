## JVM内存结构

JVM可以划分为堆，方法区，虚拟机栈，本地方法栈，计数器。

| -            | 堆                                                      | 方法区（1.8前永久代，1.8元空间）                             | 虚拟机栈       | 本地方法栈     | 计数器 |
| ------------ | ------------------------------------------------------- | ------------------------------------------------------------ | -------------- | -------------- | ------ |
| 作用         | 存放对象                                                | 类的信息，静态变量的信息，常量池，类的加载器，类和他的父类的全路径地址，类的修饰符，描述等。永久代。 | 存放对象的引用 | 存放native方法 |        |
| 是否线程安全 |                                                         | 是                                                           | 否             | 否             | 是     |
| 分区         | 新生代（eden,Surviorv from,Survior to），永久代(turner) |                                                              |                |                |        |
| JVM参数      | --XX new size,-XX maxNewSize,-xms,-xmx                  | -XX MaxPermSize,-XX permSize                                 |                |                |        |
| 共享与否     | 共享                                                    | 共享                                                         | 私有           | 私有           | 私有   |

### GC ROOT的对象

1. 虚拟机栈，局部变量表引用到的变量。
2. 方法区的静态变量。
3. 方法区的常量。
4. 本地方法栈JNI，引用到的对象。
5. JVM内部引用，一些Class对象，常驻异常对象等。
6. 所有被同步锁持有的对象。
7. 反映JVM内部情况的一些bean，JMXBean、JVMTI中注册的回调、本地代码缓存等。

### 直接内存

直接内存不是JVM的一部分，但是也会被频繁使用，NIO会使用native库直接分配堆外内存，然后通过DirectByteBuffer对象作为这快内存的引用进行操作，可以避免在JAVA堆和Native堆中来回复制数据。

本地线程分配缓冲TLAB

### 指针碰撞

假设内存区域都是连续的，用过的内存放一边，空闲的内存放另一边，中间放着一个指针作为分界点的指示器，那分配内存就是仅仅把指针向空闲空间一边挪动一段与对象大小相等的距离，这种分配方式称为指针碰撞。

### 安全点和安全区域

stw的时候需要中断线程，程序执行时只有达到安全点的时候才能暂停。

### 并发和并行概念

- 并行，多线程一起进行垃圾收集，但是用户线程会等待。
- 并发，多线程进行垃圾收集，不会使用户线程停止等待。

## 存活判定算法

- 可达性分析
  1. 虚拟机栈中本地变量表所引用的对象
  2. 静态变量引用的对象
  3. 常量引用的对象

- 二次标记。即使可达性分析中没有找到该对象的引用，也不会立即进行回收，可以在finalized()方法中进行自救。
  1. 没有覆盖finalize()
  2. finalized()方法已经被虚拟机调用，任何对象的finalized()方法只会被系统调用一次。

## 垃圾回收算法

1. 引用计数 无法解决循环引用的问题 JVM没有采用这种算法
2. 可达性分析 通过GC ROOTS去查找对象的引用链 如果没有找到 则JVM认为该对象是可回收的，栈中引用的对象和方法去静态变量所引用的对象
3. 标记删除 
4. 分区算法
5. 分代算法
6. 标记压缩
7. 复制算法

## 垃圾回收器

1. 串行回收器（serial）
2. G1回收器
3. 并行回收器 parnew、 parrell old、 parrallel Scavenge(吞吐量优先)
4. CMS回收器

### parnew收集器

新生代多线程收集器，主要是用来配合cms老生代收集器使用，使用复制算法，垃圾收集时会让用户线程停止等待。

### Parrallel Scavaenge

真正的并发收集器，垃圾收集时不会让用户线程停止，注重吞吐量，是为吞吐量而生的收集器。

主要通过两个参数控制吞吐量： 

-XX:MaxGcPauseMiles 最大停顿时间目标  

-XX:GCTimeRatio 垃圾收集时间占总时间比率

配合老生代的Parrallel Old收集器一起使用，默认老生代使用的是自己实现的Searil Old(PS Mark Swap)收集器。

### CMS回收器

通过CardTable保留了老生代对象到新生代对象的引用，CardTable是一个连续的byte数组，youngGC时不需要扫描全部的老生代，只需要扫描cardtable即可。G1回收器参考了CMS的做法，用RememberSet记录其他Region对象引用本Region对象的关系，相当于新生代记录了哪个老生代对象引用了自己。Rset引用大大减少了GC的工作量。

1. 初始标记  STW，标记GC Roots直接可达的对象，并将它们的字段压入扫描栈中等待后续扫描。G1使用外部的bitmap来记录mark信息，而不是用对象头的mark word里的mark bit。因为STW，所以通常YGC的时候借用YGC的STW顺便启动initial mark，也就是启动全局并发标记，全局并发标记与YGC逻辑上是独立的。
2. 并发标记  不需要STW，不断从扫描栈中取出引用递归扫描整个堆的对象。每扫描一个对象就会对其标记，并将其字段压入扫描栈。重复扫描过程指导扫描栈清空。过程还会扫描SATB所记录下的引用。
3. 重新标记  STW，并发标记会产生浮动碎片，这个阶段就是负责将剩下的引用处理完。这个阶段也会进行弱引用处理。CMS的remark需要重新扫描mod-union table里面的dirty card外加整个集合，而此时整个young gen都会被当成根集合的一部分，因此这个过程有可能会非常慢。
4. 并发清除 清点出有存活对象的Region和没有存活对象的Region。更新Rset

STAB stab就是初始快照，为了维持gc的正确性，避免在没有stw时标记的垃圾不被回收，通过gc roots tracing参照并发标记的过程，只要被快照到的对象时活的，在gc的过程中就认为他是活的，被快照到的对象是死的话，就算在gc的过程他被初始化也把他回收，stab保证了真正存活的对象时不会被gc回收的，但是也因此有一些在gc死掉的对象逃过了gc，导致内存里面存在浮动的垃圾（float garbage）

### G1回收器

跟其他回收器不同，将堆分为以region为单位的块，每个region都会做个唯一标记成eden,suvivior,old，G1跟CMS类似，也会有个并发标记的过程，用于发现那些regions的可回收对象多，GC时优先回收该区域对象。用户可以指定一个暂停时间，G1收集器会估算用户指定的目标时间内可以收集的区域。

YGC 当eden空间满后，会触发YGC，区别是会动态改变young region的个数，YGC仍然会STW，YGC不需要扫描整个老生代，只需要扫描RSet就可以知道老生代引用了哪些新生代中的对象。

MIXGC  这些选中被回收的Region组合的集合就叫做Collection Set简称Cset，MIXGC中Cset就是选定所有young gen里的region，外加根据globle concurrent marking统计得出收集收益最高的若干old gen region。在YGC中的CSet就是选定所有young gen里的region。通过控制young region个数控制young gc的开销。



1. 初始标记 （gc root能直接关联到的对象）
2. 并发标记 （可达性分析 可以并行）
3. 最终标记 （修正并发标记期间产生的标记变动的记录）
4. 筛选回收

### Shenandoah收集器

与G1收集器的区别

1. 支持并发整理。
2. 用连接矩阵记录region之间的引用关系（connection matrix),降低了处理跨代指针时记忆集的消耗问题，降低了伪共享的问题。
3. 默认不使用分代收集。

工作过程：

1. 初始标记。
2. 并发标记。
3. 最终标记。
4. 并发清理。
5. 并发回收。
6. 初始引用更新。
7. 并发引用更新。
8. 最终引用更新。
9. 并发清理。

转发指针解决自陷中断用户态到内核态切换的问题，转发指针在对象头维护了专向地址，通过cas保证并发更新的正确性。

### ZGC

定义：ZGC收集器是一款基于Region内存布局的，（暂时）
不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低
延迟为首要目标的一款垃圾收集器。

特征：

1. region具有动态性，划分成3种region，small region、medium region、large region

### 内存分配与回收策略

1. maxTenuringThrehold 新生代survivor最大存活年龄，如果同年龄的对象超过Survivor，会直接晋升老生代。
2.  

### JVM优化案例

| 案例分类         | 案例分析                                         | 案例现象 | 排查方法 |      |
| ---------------- | ------------------------------------------------ | -------- | -------- | ---- |
| JVM堆内存溢出    | Full GC次数较多，并伴随java heap space下面的报错 |          |          |      |
| perm区内存溢出   |                                                  |          |          |      |
| 直接分配内存溢出 |                                                  |          |          |      |
| JVM线程打满      |                                                  |          |          |      |
| GC导致长时间停顿 |                                                  |          |          |      |

### JIT技术

Just-in-time compile 第一次用到的时候才进行编译

### 引用

1. 强引用
2. 软引用 下一次GC内存不足时优先回收
3. 弱引用 下一次GC回收 
4. 虚引用 PhantomReference，不能单独使用，必须和引用队列联合使用。用于跟踪对象被垃圾回收的状态

### 优化

-XX:-UseBiasedLocking //关闭偏向锁（默认打开）

-XX:+UseHeavyMonitors //设置重量级锁


### 为什么要用mq

- 应用解耦
- 异步处理
- 消息分发
- 流量削峰
- 消息缓冲

### rabbitmq有哪些角色

- 生产者 消息的创建者，负责创建和推送消息到消息服务器
- 消费者 消息的消费者，负责处理数据和确认消息
- 代理 rabbit本身

### rabbitmq有哪些组件

- ConnectionFactory：应用程序和rabbit之间建立连接的管理器
- Channel：消息推送使用的管道
- Exchanger：交换器 用于接收和分配消息
- Queue：队列 储存消息
- RoutingKey：路由键，用于把生产者的数据分配到交换器上。
- BindingKey: 绑定键，用于把交换器的消息绑定到队列上。

### rabbitmq消息是怎么发送的

首先客户端要连接到rabbit服务器上，通过创建一个tcp连接，经过认证（校验用户名和密码）后，在真实的tcp连接上创建虚拟的连接通道channel，amqp命令都是通过信道发送过去，每个信道有唯一的id，不论是发布订阅，都是通过这个信道完成。

### 怎么保证消息的稳定性

1. 提供了事务功能 事务性能低
2. 将channel设置为confirm确认模式。

### 什么情况消息会丢失

1. 生产者投递过程丢失 通过消息队列开启ACK控制
2. 消息队列放到内存中，还没消费，宕机。  持久化到磁盘
3. 消费者消费，没处理成功。 消费者ACK

### 怎么避免消息丢失

1. 消息持久化
2. ACK确认机制
3. 设置集群镜像模式
4. 消息补偿机制
5. 关闭自动确认，启动confirm模式

### 投递失败的消息怎么处理

- 添加returnListerner逻辑，使生产者的逻辑变复杂
- 通过备份交换机去处理，需要绑定队列，匹配队列，否则消息会消失，配合mandatory参数使用，mandatory无效。

### 如何设置消息的过期时间

1. 在队列中设置，队列中所有消息都具有
2. 在消息中设置，仅对该消息有效

### 消息如何持久化

1. 声明队列必须设置durable为true，交换器和队列的持久化

2. 消息推送投递模式必须设置持久化，deliveryMode设置为2，消息的持久化

3. 消息已经到达持久化交换器。

4. 消息已经到达持久化队列。

   以上四个条件都满足才能保证消息的持久化。

### 怎么设置消息的优先级别

通过max_priority参数，消息的默认优先级为0，最高10

### 如何解决消息的不均匀消费

有时候发完消息，有两个或多个消费者同时处理消息，但是一个消费者把所有的消息处理完了，其他消费者没有拿到消息，是因为ActiveMQ

### 集群的节点类型

- 内存节点
- 磁盘节点

### 如何保证消费的可靠性传输

1. 生产者丢数据：通过confirm和transaction机制，来确保生产者不丢消息。但是transaction机制会造成吞吐量下降，如果对可靠性要求不是特别高的话，可以只针对部分核心的队列开启事务。
2. 消息队列丢数据：通过开启持久化磁盘的配置，可以和confirm机制配合使用，可以在消息持久化成功之后再发送一个ACK的信号给生产者。如果在持久化的过程中，rabbitMq宕机，生产者接受不到ACK的信号，会自动重发。持久化开启参数设置durable=true，deliveryMode=2。
3. 消费者丢数据： 关闭自动确认消息模式，采用手动确认消息。

### 消息如何保证顺序性

将需要保持前后顺序的消息放到队列中queue，只用一个消费者去消费。只保证入队列的有序性，出队列的有序性通过业务去控制，例如有场景是要先有文章，才有评论，当消费评论时，先根据文章id去数据库查找，找不到该文章则不进行消费。待之后重试。

### 如何避免消息重复投递或重复消费

消息生产时，MQ内部针对每个生产者发送的消息生成一个inner-msg-id，作为去重和幂等的依据（消息投递失败重传），避免重复的消息进入队列，消息消费时，要求消息体中必须有一个业务Id，作为去重和幂等的依据，避免同一条消息被重复消费。

重复消费的三种场景：

1. 插入到数据库，通过唯一id判断是否重复消费。
2. set到redis，可以不处理，set操作时幂等操作。
3. 依赖第三方介质，做消费记录，redis中记录消费过的全局ID，消费前先查询有没有消费记录。

### 集群

1. 单机模式
2. 普通集群（无法做到高可用） 每台机器创建一个实例，创建的queue只会放在一个实例上，每个实例都同步queue的元数据。如果连接的不是queue所在的实例，该实例会从queue所在的实例上拉取数据。无法保证高可用，当queue所在的实例宕机时，服务不可用，而且会有单实例的性能瓶颈。
3. 镜像集群模式: 每个实例都保存queue的所有数据，每次写queue，都会自动把消息自动同步到多个实例的queue上。

### 集群中唯一的磁盘节点崩溃

- 不能创建队列
- 不能创建交换器
- 不能创建绑定
- 不能添加用户
- 不能更改权限
- 不能添加和删除集群节点

### rabbitmq对集群节点停止顺序要求

必须先停止内存节点，再停止磁盘节点，否则会造成消息丢失。

### rabbitmq的广播模式

1. Fanout：所有bind到

### 私信队列和延时队列

##### 成为死信的原因

1. 消息被拒绝
2. 队列已满
3. 消息TTL过期



### RabbitMq缺点

不支持分布式，集群为主从，依赖于单机的性能，不能做横向扩展



### 跟市面的MQ对比

| 特性                    | ActiveMQ               | RabbitMQ                                       | RocketMQ                                                     | Kafka                                                        |
| ----------------------- | ---------------------- | ---------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 单机吞吐量              | 万级                   | 万级                                           | 十万级                                                       | 十万级                                                       |
| topic数量对吞吐量的影响 |                        |                                                | topic可以达到几百/几千的级别，吞吐量会有较小幅度的下降，可以支持大量的topic | topic从几十到几百个时候，吞吐量会大幅度下降，尽量保证topic数量不要太多 |
| 时效性                  | ms级                   | 微秒级，延迟最低                               | ms级                                                         | ms级以内                                                     |
| 可用性                  | 高，基于架构实现高可用 | 高，主从架构                                   | 非常高，分布式架构                                           | 非常高，分布式架构，一个数据多个副本，少数机器宕机不会导致不可用 |
| 消息可靠性              | 有较低概率丢失消息     | 高                                             | 经过参数优化配置可以做到0丢失                                | 同rocketmq                                                   |
| 功能支持                | MQ领域的功能完备       | 基于erlang开发，并发能力很强，性能极好，延时低 | MQ功能较为完善，主要是分布式的，扩展性好                     | 功能简单，只支持MQ基本的功能                                 |


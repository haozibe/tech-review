## redis实现原理

底层通过NIO实现，由单线程的多路复用器去轮询连接的io请求，当有i/o事件准备就绪时，由单线程按顺序去处理，如果空闲当前线程则堵塞等待。避免了大量的无用操作。

### 基本数据结构

- REDIS_ENCODING_RAW
- REDIS_ENCODING_INT
- REDIS_ENCODING_EMBSTR
  - embstr的创建只需分配一次内存，而raw为两次（一次为sds分配对象，另一次为objet分配对象，embstr省去了第一次）。
  - 相对地，释放内存的次数也由两次变为一次。
  - embstr的objet和sds放在一起，更好地利用缓存带来的优势。
- REDIS_ENCODING_HT
- REDIS_ENCODING_SKIPLIST
- REDIS_ENCODING_INTSET
  - 有序集合 INT_16和INT_32之间转换，不支持降级
- REDIS_ENCODING_ZIPLIST
  - 压缩链表的特性 只分配一次连续的内存
- REDIS_ENCODING_LINKEDLIST

### 支持数据结构

1. string 动态字符串
2. list 链表
3. zset 数据结构跳跃表和哈希表
4. set  哈希表
5. hash 哈希表
   - redis的哈希表是如何扩容的，渐进式rehash的过程。
   - 跟jdk的hashmap对比
   - 如果rehash过程新表需要扩容怎么办
6. geo
7. hyperloglog
8. Pub/sub

### redis并发访问解决

由于redis内部是单线程的，不会有并发的问题，但是客户端获取连接时，有可能存在连接超时，数据转换错误，堵塞等问题，这些都是由于客户端连接混乱造成的。

1. 客户端为保证每个客户端都有序访问redis，对连接池化，对读写redis操作加锁。
2. 服务端采用setnx加锁。

### redis持久化方式

1. rdb，bgsave命令做镜像持久化，将数据产生快照保存到本地磁盘，比较耗性能，持久化时可能会造成短时间停顿。bgsave的原理，通过fork和cow，fork创建出子进程进行bgsave操作，cow指的是copyAndWrite，创建子线程后，父子线程共享数据，父线程继续提供读写服务，新的数据跟子进程分开。

   服务器以主服务器模式运行，启动时载入RDB文件会检查键是否过期，如果过期是不会再载入。如果是以服务器模式运行，不会对键是否过期进行校验，全部载入。主从数据同步时，从服务器的数据会清空，所以过期键载入RDB文件的从服务器也不会造成影响。

2. aof，增量持久化，对操作redis的所有指令做实时同步到磁盘，redis重新拉起时，会把这些指令全部执行一次。会存在数据丢失，因为在高性能的基础下，实事同步是不现实的，会存在时间差，如果将间隔设为1s，那么这1s内的数据就会丢失。

   通常rdb可以做冷备，结合aof实现redis的高可用。

### 为什么单线程还那么快

1. 基于内存操作。
2. 数据结构简单。
3. 单线程避免上下文切换和竞争。
4. 采用NIO的多路复用模型。
5. 底层模型不同，redis自己实现了一套VM机制。

### 使用分布式锁

MD5加密作为key，请求之前先去获取锁，拿到锁后再继续进行下去。请求结束之后释放锁。

## redis集群

1. 主从。从库只有读功能，不能主动写入。主库有读写功能，每次写入后都更新到从库。如果主库或从库宕机，会存在数据读取不到的风险。主从同步是基于bgsave，做同步时，主节点执行一次bgsave，并同时将后续修改的数据记录到内存buffer中，待完成后rdb文件全量同步到复制节点，复制节点收到rdb文件后，加载到内存，然后通知主节点将期间修改记录的指令同步到复制节点，进行重放就完成了主从同步。

2. 哨兵模式。一个稳健的哨兵模式至少有三个sentinel，通过sentinel启动redis后，哨兵会间隔一段时间发送请求给master，如果响应时间超出最晚响应时间，该哨兵会把该节点标记为已下线，然后投票选举出新的master节点。至少要有一主一从。
3. 集群模式。每个节点储存的数据都是不一样的，通过key的hash去分配数据储存到哪个节点。至少有三个master，每个master至少有一个 从节点。

## redis回收机制

当给key设置过期时间后，当key已到达过期时间，该key失效，但是这个时候并没有回收。

1. 定时删除。给设置了过期时间的key创建定时器，如果超时则立刻回收。
2. 惰性删除。当访问时才判断是否失效，失效则回收。
3. 定期删除。每隔一段时间去扫描一批过期key的字典，并清除。

## redis内存淘汰策略

1. noeviction。当内存不足时，写入命令抛错。
2. allkeys-lru：当内存不足时，移除最少使用的key。
3. allkeys-random：当内存不足时，随机移除某个key。
4. volatile-lru：当内存不足时，在设置了过期时间的key中，移除最少使用的key。

   volatile-random：当内存不足时，在设置了过期时间的key中，随机移除某个key。
6. volatile-ttl：当内存不足时，有更早过期时间的key优先移除。

### redis高级指令

1. keys可以扫出指定模式的Key列表。堵塞。
2. scan指令可以无堵塞的提取出指定模式的key列表。

### redis原子性

1. 单个操作时原子性的，同一时间只能执行一个操作，要么全部成功，要么全部失败。
2. 多个操作也能支持事务，通过MUTL和EXEC指令。

### redis实现事务的原理

1. 批量操作在发送EXEC命令前被放入缓存。
2. 收到EXEC命令进入事务执行，事务中任意命令执行失败，其他的命令都不会被执行。
3. 在事务执行过程中，其他客户端提交的命令请求不会插入到事务执行命令序列中。

### redis常用命令

1. String：set get decr incr mget
2. List: lpush rpush lpop rpop lrange
3. Hash: hget hset hgetAll
4. Set: sadd,spop,smembers,sunion
5. SortedSet: zadd,zrange,zrem,zcard

### redis的pipeline

pipeline作用就是把多个命令通过一次网络io发送执行。由于是多个命令一次发送，所以这些命令有一个要求就是不能有依赖关系。

### redis跳表和压缩表

### redis高并发下的优化

1. 使用集群。用哨兵保证高可用，用集群分片分散多个redis实例的工作量。
2. 选择合理的垃圾回收策略
3. 设置key值的存活时间
4. hashes的高级用法
5. 使用pipeline插入多条数据
6. 停止使用keys，使用scan替代

### redis线程模型

redis是单线程的程序，为了提高IO的效率采用的是多路复用的IO模型。在linux中用epoll在mac用kqueue，实现复杂度为O(1)的多路复用函数。什么是多路复用，意思就是会有一个线程去轮询已经有有效IO请求的通道，逐一去处理。



客户端建立socket请求 -> IO多路复用器监听到socket请求 ->将产生事件的socket压到内存队列 -> 事件调派器取出队列的socket，交给连接应答器 -> 连接应答器根据socket类型指定事件处理器进行关联 -> 连接应答器创建一个与客户端通信的socket01 -> 客户端发送set key value请求 -> socket01产生新事件 -> io多路复用器将socket01压入内存队列 ->事件分派器从队列获取事件 -> 委派给关联的事件处理器 ->事件处理器处理 -> 关联命令回复处理器 ->

客户端准备好接受请求 -> socket01产生一个AW_WRITABLE事件  ->事件分派器找到关联的命令回复处理器 ->回复结果 -> 取消事件和命令回复器的关联

### 过期键的删除

从服务器不会主动删除过期键，当有一个过期键的get请求过来时，会按正常返回，当这个键没有过期，只有当主服务器发现该键过期时，才会发一条DEL命令给从服务器。过期键的del操作由主服务器控制。



### RedLock算法



### 布隆过滤器



### Codis和redis-cluster区别



### redis如何实现主从一致性问题



### redis缓存双写不一致问题如何解决

1. 延迟双删
2. 内存队列 复杂
3. 分布式锁
4. 读写锁 redission.readWriteLock 读多写少
5. 设置个缓存超时时间，牺牲一致性
6. canal



### redis性能高原因

1. 内存操作
2. 多路复用,nio,epoll
3. 数据结构 sds
### 二叉树

1. 第i层的节点总数不会超过2i-1;
2. 深度为h的二叉树最多有2h-1个节点，最少有h个节点。
3. 对任意二叉树，其叶子节点数为n0，而度数为2的结点总数为n2，则n0=n2+1;
4. 具有n个结点的完全二叉树深度为log2(n+1);



### 二叉查找树

1. 若左子树不空，则左子树上所有节点均小于根节点值，若右树不空，右树上所有节点值均大于根节点值。
2. 左右子树也为二叉排序树。
3. 没有键值相等的节点。

#### 插入规则

1. 若当前树为空，则插入的元素为根节点。
2. 若插入的元素小于根节点值，则将元素插入到左树种。
3. 若插入的元素不小于根节点值，则将元素插入到右树种。

#### 删除规则

1. 若p为叶子节点，直接删除该节点，再修改其父节点的指针。
2. p为单支节点，让p的子树与p的父亲节点相连，删除p即可。
3. p的左子树和右子树均不为空，找到p的后继y，因为y一定没有左子树，所以可以删除y，让y的父亲节点成为y的右子树的节点，并用y的值代替p的值

### 平衡二叉树

1. 最小二叉平衡术的节点公式：F(n)=F(n-1)+F(n-2)+1
2. 任意节点的两个儿子子树的高度相差不超过1

#### AVL树

1. AVL树是最先发明的自平衡二叉查找树。AVL任何节点的两个儿子子树的高度最大差别为1，所以它被称为高度平衡树。
2. 左左和右右只需要单旋转，左右和右左需要双旋转。
3. 单旋转，双旋转（左左旋转和右右旋转）

### LSM树

牺牲了部分读的性能来换取写的性能，实现读写之间的平衡。Hbase，LevelDB、Tair、nessDB采用LEM树的结构。LSM可以快速建立索引。

在内存中建立有序的小树，当小树膨胀到一定大小的时候回flush到磁盘，归并merge到大树里面。

####  红黑树

1. 节点是红色或黑色
2. 根是黑色
3. 所以叶子都是黑色（叶子为NIL节点)
4. 每个红色节点必须有两个黑色的子节点（从每个叶子到根的所有路径上不能有两个连续的红色节点）
5. 任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（保证最长路径是最短路径的两倍 最坏情况下红色节点的数量=黑色节点）

#### 红黑树的自平衡

1. 增加节点并标记为红色，如果设为黑色，就会导致根到叶子节点的路径上有一条路上，多一个额外的黑节点。
2. 根据实际情况进行旋转并调整节点颜色。

### B树

1. 可以有多于两个的子节点。
2. 任意非叶子节点最多只有M个儿子；且M>2;
3. 根节点的儿子数为[2,M];
4. 除根节点外的节点儿子数为[M/2,M];
5. 非叶子结点的关键字个数=指向儿子的指针个数-1
6. 每个结点存放至少M/2-1（向上取整）和至多M-1个关键字
7. 所有叶子结点位于同一层

### B+树

1. 非叶子结点的子树指针与关键字个数相同。
2. 非叶子结点的子树指针P[i],指向关键字属于K[i],K[i+1]的子树（B-树是开区间）；
3. 为所有叶子结点增加一个链指针；
4. 所有关键字都在叶子结点出现
5. 非叶子结点相当于叶子结点的索引（非聚簇索引），叶子结点相当于储存关键字数据的数据层。
6. 叶子结点是链表，范围查询时只需要遍历链表即可。
7. 将多个值通过连续区间存放，一次寻道读取多个数据，降低树的高度，插入新的节点不必要移动全部节点。

### B树和B+树区别

1. B树可以在非叶子结点上找到数据，B树只能通过叶子结点，非叶子结点都是作为索引。目的为了可以减轻IO压力。一次读到内存的数据变少了。
2. B+树的查询效率更加稳定，所有关键字查询路径长度相同，都需要走到叶子结点，查询效率更稳定。
3. 扫库时，只需要扫一遍叶子结点就可以了，而B树需要进行中序遍历按序来扫，效率更低。



